<!-- THREE THINGS YOU NEED FOR EVERY THREEJS PROJECT - SCENE, CAMERA AND RENDERER -->
<!-- Deltas = the changing of the x and y coordinates when a user moves a mouse -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>TrackBall</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/main.css"
</head>
<body>
    <section id="welcome-screen">
        <canvas id="splash-graphic" width="20rem" height="20rem"></canvas>
        <div id="splash-wrapper">
            <h1 id="title" class="linear-title">PUSH AND BLOCK</h1>
            <section id="blurb">
                <h2>WELCOME TO PUSH AND BLOCK!  THE GAME THAT'S NOT A GAME. YET.</h2>
            <button id="start">LET'S GO!</button>
            </section>
        </div>
    </section>
    <div id="timer">Timer: 0</div>
    
    <!-- <h1>Welcome</h1> -->
    
    <script src="js/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script> 
    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/app.js"></script>

    <script type="text/javascript" src="/js/physi.js"></script>


    <script>
        start.addEventListener('click', init);


        Physijs.scripts.worker = '/js/physijs_worker.js';
        Physijs.scripts.ammo = '/js/ammo.js';


        function init() {

        // SETTING THE SCENE

        welcomeScreen.style.visibility = 'hidden';

        var scene = new Physijs.Scene();
        scene.setGravity(new THREE.Vector3(0, -300, 0));



        var camera = new THREE.PerspectiveCamera(
            75, // field of view
            window.innerWidth/window.innerHeight, // aspect ratio - based on browser innerwidth and innerheight
            .1, // near (0.1) and far (1000) plane
            10000        
            )
        // camera.position.z = 10 // setting starting camera position at the z axis
        var renderer = new THREE.WebGLRenderer({antialias: true}); // A few renderers but the webgl renderer allows us to make crazy scenes with no limitations. Takes a few properties but antialias allows the result not to look jagged.
        renderer.setClearColor("#cce0ff") // another way of saying background color
        renderer.setSize(window.innerWidth,window.innerHeight);
        // camera.lookAt(scene.position);  

        document.body.appendChild(renderer.domElement); // create our canvas element with our render settings
            

        // MUSIC

        var listener = new THREE.AudioListener();
        camera.add( listener );

        // create a global audio source
        var sound = new THREE.Audio( listener );

        // load a sound and set it as the Audio object's buffer
        var audioLoader = new THREE.AudioLoader();
        audioLoader.load( '/audio/toomanyzooz.mp3', function( buffer ) {
            sound.setBuffer( buffer );
            sound.setLoop( true );
            sound.setVolume( 0.5 );
            sound.play();
        });
        // AUTO RESIZE WINDOW
        window.addEventListener('resize' , () => { 
            renderer.setSize(window.innerWidth, window.innerHeight); // resizes the window to be responsive
            camera.aspect = window.innerWidth / window.innerHeight; // to change the aspect ratio of the browser
            camera.updateProjectionMatrix(); // we have to call this on the camera every time an adjustment is made
        })

        // SETTING THE PLANE
        var loader = new THREE.TextureLoader();
        var floor = getPlane(loader);
        function getPlane(loader) {
            var texture = loader.load('pics/franklin.jpg');
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
            texture.repeat.set( 10, 10 );
            var material = new THREE.MeshBasicMaterial({
            map: texture, side: THREE.DoubleSide
            });
            var geometry = new THREE.PlaneGeometry(5000, 5000, 5000, 100);
            var plane = new Physijs.BoxMesh(geometry, material);
            plane.position.y = -60;
            plane.rotation.x = Math.PI / 2;
            scene.add(plane);
            return plane;
        }

        // WEATHER
        // scene.fog = new THREE.FogExp2( 0xcccccc, 0.5555 );
            
        // TYPE OF CAMERA
        controls = new THREE.TrackballControls( camera, renderer.domElement);

        // CONTROLS
        function getControls(camera, renderer) {
            var controls = new THREE.TrackballControls(camera, renderer.domElement);
            controls.zoomSpeed = 10;
            controls.panSpeed = 3.4;
            return controls;
        }
        
        // ADDING OBJECTS
        function getBox () {
           var restitution = 0.1
           var friction = 1.0
           var geometry = new THREE.SphereGeometry(60, 60, 60) // (radius, width, height) box geometry because we're making a cube
            var boxMaterial = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: 0xF7F7F7}));
            
            var material = Physijs.createMaterial(
                new THREE.MeshBasicMaterial({ color: 'red' }),
                friction,
                restitution
            );
            
            var box = new Physijs.BoxMesh(
                geometry, boxMaterial);
            
            // CREATING A GROUP FOR TRANSLATIONS/ROTATIONS
            // var boxGroup = new THREE.Group();
            // boxGroup.add(box)
            // boxGroup.position.set(0, 24, 100);
            // scene.add( box,boxGroup);
            // return [box, boxGroup];
        }

        // GLOBAL VARIABLES
        var material = new THREE.MeshLambertMaterial({
                color: 0xB1E5F7
            });
        var geometry = new THREE.BoxGeometry(50, 50, 50) // (radius, width, height) box geometry because we're making a cube


        // RANDOMIZING OBJECTS
        for(var i =0; i < 75
        ; i++) {
            var box = new Physijs.BoxMesh(geometry, material);
            box.position.x = (Math.random() - 0.5) * 1000;
            // box.position.y = (Math.random() - 0.5) * 1000;
            box.position.z = (Math.random() - 0.5) * 1000;
            scene.add(box);
        }

        // STORING PRESSED KEYS
        function addListeners() {
            window.addEventListener('keydown', function(e) {
            pressed[e.key.toUpperCase()] = true;
            })
            window.addEventListener('keyup', function(e) {
            pressed[e.key.toUpperCase()] = false;
            })
        }

        // MOVING THE BOX'S POSITION

        function moveBox() {
            
            var delta = clock.getDelta(); // seconds
            var moveDistance = 200 * delta; // 200 pixels per second
            var rotateAngle = Math.PI / 2 * delta; // pi/2 radians (90 deg) per sec
            box.setLinearVelocity(new THREE.Vector3(0, 0, 0));
            box.setAngularVelocity(new THREE.Vector3(0, 0, 0));
            box.__dirtyRotation = true;
            box.__dirtyPosition = true;
            // move forwards/backwards/left/right
            if ( pressed['W'] ) {
            // box.rotateOnAxis(new THREE.Vector3(1,0,0), -rotateAngle)
            box.translateZ( -moveDistance );
            }
            if ( pressed['S'] ) {
            box.translateZ( moveDistance );
            // if ( pressed['Q'] )
            // box.translateX( -moveDistance );
            // if ( pressed['E'] )
            // box.translateX(  moveDistance ); 
            }
            // rotate left/right/up/down
            var rotation_matrix = new THREE.Matrix4().identity();
            if ( pressed['A'] )
            box.rotateOnAxis(new THREE.Vector3(0,1,0), rotateAngle);
            if ( pressed['D'] )
            box.rotateOnAxis(new THREE.Vector3(0,1,0), -rotateAngle);
            // if ( pressed['R'] )
            // box.rotateOnAxis(new THREE.Vector3(1,0,0), rotateAngle);
            // if ( pressed['F'] )
            // box.rotateOnAxis(new THREE.Vector3(1,0,0), -rotateAngle);
        }

        // MOVING THE CAMERA
        function moveCamera() {
            var relativeCameraOffset = new THREE.Vector3(0,50,200);
            var cameraOffset = relativeCameraOffset.applyMatrix4(box.matrixWorld);
            camera.position.x = cameraOffset.x;
            camera.position.y = cameraOffset.y;
            camera.position.z = cameraOffset.z;
            camera.lookAt(box.position);
        }



        
        // **** ADD another object **********************
        // var circle = new THREE.SphereGeometry(1, 1, 50)
        // var circleMaterial = new THREE.MeshLambertMaterial({color: 0xF8B3C8})
        // meshY = -10;
        // for(var i =0; i < 20; i++) {
            //     var circleMesh = new THREE.Mesh(circle, circleMaterial);
            //     circleMesh.position.x = (Math.random() - 0.5) * 10;
            //     circleMesh.position.y = (Math.random() - 0.5) * 10;
            //     circleMesh.position.z = (Math.random() - 0.5) * 10;
            //     scene.add(circleMesh);
            //     meshY+=1;
            // }
            
            // LIGHTING - 1
            var light = new THREE.PointLight(0xFFFFFF, 1, 1000) // color, intensity, distance - get props off documentation
            light.position.set(0, 0, 0); // based off of x,y,z
            scene.add(light);
            
            // LIGHTING - 2
            var light = new THREE.PointLight(0xFFFFFF, 2, 1000)
            light.position.set(0, 0, 25); 
            scene.add(light);
            
            // ANIMATION
            var raycaster = new THREE.Raycaster(); // allows animation with the mouse
            var mouse = new THREE.Vector2(); // Vector2 uses only x and y
            // function render() {
            //     requestAnimationFrame(render) // creates a loop that causes the renderer to draw the scene every time the screen is refreshed so it doesn't become distorted when resizing the browser
            //     // mesh.rotation.y += .01; // allows it to rotate every time the render method is called which is about 60 fps
            //     // mesh.rotation.x += .1; // allows it to rotate every time the render method is called which is about 60 fps
            //     renderer.render(scene, camera) // we have to call the renderer method on the renderer
            //     // moveCamera();
            //     // moveBox();
            // }

        // function onMouseMove(event) { // this is all in tandem with window.addEventlistener below
        //     event.preventDefault();
        //     mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        //     mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        //     raycaster.setFromCamera(mouse, camera);

        //     var intersects = raycaster.intersectObjects(scene.children, true);
        //     for (var i = 0; i < intersects.length; i++) {
        //         intersects[i].object.material.color.set(0xff0000)
        //         // Tweening - Short for in-betweening, the process of generating intermediate frames between two images to give the appearance that the first image evolves smoothly into the second image.
        //         this.tl = new TimelineMax() // a JS sequencing tool acts a container for tweens to control animation. Provides methods to multiple diff aspects of animation
        //         this.tl.to(intersects[i].object.scale, 1, {x: 2, ease: Expo.easeOut}) // first movement and expansion of box
        //         this.tl.to(intersects[i].object.scale, .5, {x: .5, ease: Expo.easeOut}) // x is how big the width ends
        //         this.tl.to(intersects[i].object.position, 50, {z: 40, ease: Expo.easeOut}) // first how fast to end position/second x position on screen
        //         this.tl.to(intersects[i].object.rotation, .5, {y: Math.PI*.5, ease: Expo.easeOut}, "+=-1.5") // this makes it happen 1.5 seconds before it normally would
        //     }
        // }

        // function onMouseClick(event) { // this is all in tandem with window.addEventlistener below
        //     event.preventDefault();
        //     mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        //     mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        //     raycaster.setFromCamera(mouse, camera);

        //     var intersects = raycaster.intersectObjects(scene.children, true);
        //     for (var i = 0; i < intersects.length; i++) {
        //         intersects[i].object.material.color.set(0xbd2861)
        //         // Tweening - Short for in-betweening, the process of generating intermediate frames between two images to give the appearance that the first image evolves smoothly into the second image.
        //         this.tl = new TimelineMax() // a JS sequencing tool acts a container for tweens to control animation. Provides methods to multiple diff aspects of animation
        //         this.tl.to(intersects[i].object.scale, 1, {x: 2, ease: Expo.easeOut}) // first movement and expansion of box
        //         this.tl.to(intersects[i].object.scale, .5, {x: .5, ease: Expo.easeOut}) // x is how big the width ends
        //         this.tl.to(intersects[i].object.position, .5, {z: 5, ease: Expo.easeOut}) // first how fast to end position/second x position on screen
        //         this.tl.to(intersects[i].object.rotation, .5, {y: Math.PI*.5, ease: Expo.easeOut}, "+=-1.5") // this makes it happen 1.5 seconds before it normally would
        //     }
        // }

        
        var pressed = {}
        var clock = new THREE.Clock();


        var boxData = getBox(scene);
        var box = boxData[0];
        var boxGroup = boxData[1];

        render = function() {
            scene.simulate();
            renderer.render( scene, camera);
            requestAnimationFrame( render );
            moveCamera();
            moveBox();
            addListeners();
        }
    
        render() 
        }

        // document.body.addEventListener('click', () => {
        //     this.tl.play(); // since it's paused above, this function allows the user to play the TimeLineMax on a user click ANYWHERE on the screen
        // })

        window.addEventListener('click', onMouseClick); 
        window.addEventListener('mousemove', onMouseMove);
        
    </script>
</body>
</html>